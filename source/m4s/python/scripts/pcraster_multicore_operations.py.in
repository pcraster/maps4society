import types
import pcraster._pcraster as _pcraster
import _pcraster_multicore as _pmc
from _pcraster_multicore import set_nr_cpus


# TODO: the get_ ... need more error checking, string input handling
def get_scalar_field(arg):
  res = arg

  if isinstance(arg, _pcraster.Field):
    return(arg)
  elif isinstance(arg, types.IntType) or isinstance(arg, types.LongType) or isinstance(arg, types.FloatType):
    res = _pcraster.newNonSpatialField(float(arg))
  else:
    raise RuntimeError("conversion of argument {} not possible".format(type(arg)))

  return res







# just get a spatial or nonspatial
# correct SV should be checked in the C++ code
def get_field(arg):
  res = arg

  if isinstance(arg, _pcraster.Field):
    return(arg)
  elif isinstance(arg, types.StringTypes):
    return(_pcraster.readmap(arg1))
  elif isinstance(arg, types.IntType) or isinstance(arg, types.LongType) or isinstance(arg, types.FloatType):
    return(_pcraster.newNonSpatialField(bool(arg)))

  #else:



#def get_boolean_field(arg):
#  res = arg
#
#  if isinstance(arg, _pcraster.Field):
#    return(arg)
#  if not isinstance(arg, types.BooleanType):
#    raise RuntimeError("conversion of argument {} to Boolean not possible".format(type(arg)))
#
#  return res
#












def _and(arg1, arg2):
  try:
    arg1 = get_field(arg1)
    arg2 = get_field(arg2)
    return _pmc._and(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.and: {}".format(str(exception)))

#def _or(arg1, arg2):
#  try:
#    arg1 = get_boolean_field(arg1)
#    arg2 = get_boolean_field(arg2)
#    return _pmc._or(arg1, arg2)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.or: {}".format(str(exception)))
#
#def pcrmcnot(arg1):
#  try:
#    arg1 = get_boolean_field(arg1)
#    return _pmc._not(arg1)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.not: {}".format(str(exception)))

#def defined(arg1):
#  try:
#    arg1 = get_field(arg1)
#    return _pmc.defined(arg1)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.defined: {}".format(str(exception)))




def add(arg1, arg2):
  try:
    arg1 = get_scalar_field(arg1)
    arg2 = get_scalar_field(arg2)
    return _pmc.add(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.add: {}".format(str(exception)))


def sub(arg1, arg2):
  try:
    arg1 = get_scalar_field(arg1)
    arg2 = get_scalar_field(arg2)
    return _pmc.sub(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.sub: {}".format(str(exception)))

def mul(arg1, arg2):
  try:
    arg1 = get_scalar_field(arg1)
    arg2 = get_scalar_field(arg2)
    return _pmc.mul(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.mul: {}".format(str(exception)))

def div(arg1, arg2):
  try:
    arg1 = get_scalar_field(arg1)
    arg2 = get_scalar_field(arg2)
    return _pmc.div(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.div: {}".format(str(exception)))















def power(arg1, arg2):
  try:
    arg1 = get_scalar_field(arg1)
    arg2 = get_scalar_field(arg2)
    return _pmc.power(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.pow: {}".format(str(exception)))


def cos(arg1):
  try:
    arg1 = get_scalar_field(arg1)
    return _pmc.cos(arg1)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.cos: {}".format(str(exception)))



def sqrt(arg1):
  try:
    arg1 = get_scalar_field(arg1)
    return _pmc.sqrt(arg1)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.sqrt: {}".format(str(exception)))

def slope(arg1):
  try:
    arg1 = get_scalar_field(arg1)
    return _pmc.slope(arg1)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.slope: {}".format(str(exception)))



def upstream(arg1, arg2):
  try:
    arg1 = get_field(arg1)
    arg2 = get_field(arg2)
    return _pmc.upstream(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.downstream: {}".format(str(exception)))




# these ones below here can be generated?!
# assume type checking in the C++ code
# 


def equal(arg1, arg2):
  try:
    arg1 = get_field(arg1)
    arg2 = get_field(arg2)
    return _pmc.equal(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.equal: {}".format(str(exception)))

#def larger(arg1, arg2):
#  try:
#    arg1 = get_field(arg1)
#    arg2 = get_field(arg2)
#    return _pmc.larger(arg1, arg2)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.larger: {}".format(str(exception)))
#
#def larger_equal(arg1, arg2):
#  try:
#    arg1 = get_field(arg1)
#    arg2 = get_field(arg2)
#    return _pmc.larger_equal(arg1, arg2)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.larger_equal: {}".format(str(exception)))
#
def less(arg1, arg2):
  try:
    arg1 = get_field(arg1)
    arg2 = get_field(arg2)
    return _pmc.less(arg1, arg2)
  except RuntimeError as exception:
    raise RuntimeError("pcraster_multicore.less: {}".format(str(exception)))

#def less_equal(arg1, arg2):
#  try:
#    arg1 = get_field(arg1)
#    arg2 = get_field(arg2)
#    return _pmc.less_equal(arg1, arg2)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.less_equal: {}".format(str(exception)))
#
#def unequal(arg1, arg2):
#  try:
#    arg1 = get_field(arg1)
#    arg2 = get_field(arg2)
#    return _pmc.unequal(arg1, arg2)
#  except RuntimeError as exception:
#    raise RuntimeError("pcraster_multicore.unequal: {}".format(str(exception)))
#
